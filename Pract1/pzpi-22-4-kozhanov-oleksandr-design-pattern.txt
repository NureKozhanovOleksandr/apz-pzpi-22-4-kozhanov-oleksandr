Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії


Звіт 
з практичного заняття №1
з дисципліни «Архітектура програмного забезпечення»
за темою «Патерни проєктування»



Роботу виконав
ст. гр. ПЗПІ-22-4 
Кожанов Олександр Юрійович

Перевірив
ст. викл. каф. ПІ 
Сокорчук Ігор Петрович





Харків 2025
 
1 ІСТОРІЯ ЗМІН

Таблиця 1.1 – Історія змін звіту
№	Дата	Версія звіту	Опис змін та виправлень
1	16.04.2025	0.1	Додано розділ «Завдання»
2	17.04.2025	0.2	Додано розділ «Опис виконаної роботи»
3	17.04.2025	0.3	Створено розділ «Висновки» та додатки 
«Додаток А», «Додаток Б», «Додаток В»
4	17.04.2025	1.0	перевірено відповідність вимогам ДСТУ 3008:2015




 
2 ЗАВДАННЯ

Вивчити патерн проєктування Command, з’ясувати його значення у розробці програмного забезпечення та основні принципи його роботи. Дослідити приклади реалізації патерну Command мовою JavaScript. Розглянути приклади використання цього патерну для організації взаємодії між різними компонентами або системами, зокрема у контексті інкапсуляції запитів як об’єктів.

3 ОПИС ВИКОНАНОЇ РОБОТИ

3.1 Аналіз патерну Command
Основна ідея патерну Command полягає в інкапсуляції запитів у вигляді об’єктів, що дозволяє відокремити ініціатора дії від її виконавця. Це забезпечує гнучкість у виконанні операцій, підтримку скасування дій та збереження історії запитів, що є особливо корисним у фронтенд-розробці, наприклад, для реалізації функціоналу undo/redo. Патерн Command реалізується через три ключові компоненти:
•	Command: інтерфейс, що визначає метод виконання (execute) та, за потреби, скасування (undo);
•	Invoker: об’єкт, який викликає команду, не знаючи деталей її реалізації;
•	Receiver: об’єкт, що виконує конкретну дію.
Основні принципи роботи:
•	Ізоляція логіки виконання від ініціатора запиту;
•	Можливість збереження історії команд для повторного виконання чи скасування;
•	Забезпечення розширюваності через додавання нових команд без зміни клієнтського коду.

3.2 Аналіз прикладів коду на мові JavaScript (React)
Для поглибленого розуміння патерну Command було досліджено приклад його реалізації на мові JavaScript у контексті бібліотеки React. Приклад коду наведено у додатку В.

3.2.1 Реалізація патерну Command у React
Реалізація патерну Command у React базується на використанні об’єктно-орієнтованого підходу, де команда інкапсулює дію, пов’язану з обробкою стану форми. У прикладі створено клас Command, який визначає методи execute() та undo(). Конкретна команда SaveFormCommand відповідає за збереження даних форми та їх скасування.
Клас FormReceiver виступає як Receiver, керуючи станом форми. React-компонент FormComponent виступає в ролі Invoker, викликаючи команду через обробники подій (натискання кнопок «Зберегти» та «Скасувати»). Історія команд зберігається у стані компонента за допомогою хука useState, що дозволяє реалізувати функціонал скасування.
Ця реалізація демонструє гнучкість патерну, оскільки нові команди (наприклад, для очищення форми) можна додати без модифікації компонента. Використання хуків React забезпечує інтеграцію патерну з сучасними підходами до розробки інтерфейсів, а ізоляція логіки команд сприяє легшому тестуванню та підтримці коду. 
4 ВИСНОВКИ

Патерн Command є ефективним інструментом для інкапсуляції запитів у вигляді об’єктів, що дозволяє відокремити ініціатора дії від її виконавця та забезпечити гнучкість у реалізації операцій. Він особливо корисний у фронтенд-розробці на React для обробки подій, реалізації функціоналу скасування/повторення дій та централізованого управління операціями.
Реалізація патерну в React, заснована на об’єктно-орієнтованому підході, забезпечує ізоляцію логіки, розширюваність і підтримуваність коду. Використання хуків, таких як useState, дозволяє інтегрувати паттерн із сучасними практиками розробки.
Вибір патерну Command для інтерактивних додатків сприяє підвищенню модульності та зменшенню залежностей у коді. У порівнянні з іншими паттернами, такими як Strategy чи State, Command фокусується на діях та їх історії, що робить його оптимальним для систем із динамічними взаємодіями.
 
ДОДАТОК А ПОСИЛАННЯ НА ВІДЕОЗАПИС ДОПОВІДІ ТА ХРОНОЛОГІЧНИЙ ОПИС

Відеозапис доповіді на YouTube: https://youtu.be/pAKuDm-Xd6Q
00:00 Вступ. Пояснення теми та мети роботи 
00:32 Визначення паттерну Command 
01:08 Пояснення мети паттерну Command 
01:40 Структура паттерну Command 
02:16 UML-діаграма паттерну Command та її пояснення 
02:48 Пояснення переваг паттерну Command 
03:21 Пояснення недоліків паттерну Command 
03:56 Сфери застосування паттерну Command 
04:30 Представлення прикладу використання паттерну у React-застосунку 05:07 Аналіз представленого прикладу 
05:38 Порівняння паттерну Command із іншими паттернами 
06:18 Висновки 
06:48 Джерела інформації, використані для створення докладу
 
ДОДАТОК Б
Презентація
 
Рисунок Б.1 – Титульна сторінка презентації

 
Рисунок Б.2 – Визначення патерну Command
 
Рисунок Б.3 – Мета патерну

 
Рисунок Б.4 – Структура патерну
 
Рисунок Б.5 – UML-діаграма патерну

 
Рисунок Б.6 – Переваги патерну


 
Рисунок Б.7 – Недоліки патерну

 
Рисунок Б.8 – Застосування патерну
 
Рисунок Б.9 – Приклад коду на React

 
Рисунок Б.10 – Аналіз прикладу
 
Рисунок Б.11 – Порівняння з іншими патернами

 
Рисунок Б.12 – Висновки
 
Рисунок Б.13 – Використані джерела

 
ДОДАТОК В ПРОГРАМНИЙ КОД

1  import React, { useState } from 'react';
2  
3  class Command {
4    execute() {}
5    undo() {}
6  }
7  
8  class SaveFormCommand extends Command {
9    constructor(receiver, data) {
10      super();
11      this.receiver = receiver;
12      this.data = data;
13      this.previousData = null;
14    }
15  
16    execute() {
17      this.previousData = this.receiver.getData();
18      this.receiver.save(this.data);
19    }
20  
21    undo() {
22      this.receiver.save(this.previousData);
23    }
24  }
25  
26  class FormReceiver {
27    constructor() {
28      this.data = '';
29    }
30  
31    save(data) {
32      this.data = data;
33    }
34  
35    getData() {
36      return this.data;
37    }
38  }
39  
40  function FormComponent() {
41    const [formData, setFormData] = useState('');
42    const [history, setHistory] = useState([]);
43    const receiver = new FormReceiver();
44  
45    const handleSave = () => {
46      const command = new SaveFormCommand(receiver, formData);
47      command.execute();
48      setHistory([...history, command]);
49    };
50  
51    const handleUndo = () => {
52      const lastCommand = history.pop();
53      if (lastCommand) {
54        lastCommand.undo();
55        setHistory([...history]);
56        setFormData(receiver.getData());
57      }
58    };
59  
60    return (
61      <div>
62        <input
63          type="text"
64          value={formData}
65          onChange={(e) => setFormData(e.target.value)}
66        />
67        <button onClick={handleSave}>Зберегти</button>
68        <button onClick={handleUndo} disabled={!history.length}>
69          Скасувати
70        </button>
71        <p>Дані: {receiver.getData()}</p>
72      </div>
73    );
74  }
75  
76  export default FormComponent;
