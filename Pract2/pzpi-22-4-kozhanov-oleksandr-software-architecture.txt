Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії


Звіт 
з практичного заняття №2
з дисципліни «Архітектура програмного забезпечення»
за темою «Архітектура системи Figma»



Роботу виконав
ст. гр. ПЗПІ-22-4 
Кожанов Олександр Юрійович

Перевірив
ст. викл. каф. ПІ 
Сокорчук Ігор Петрович





Харків 2025
 
1 ІСТОРІЯ ЗМІН

Таблиця 1.1 – Історія змін звіту
№	Дата	Версія звіту	Опис змін та виправлень
1	17.04.2025	0.1	Додано розділ «Завдання»
2	18.04.2025	0.2	Додано розділ «Опис виконаної роботи»
3	18.04.2025	0.3	Створено розділ «Висновки» та додатки 
«Додаток А», «Додаток Б», «Додаток В»
4	18.04.2025	1.0	перевірено відповідність вимогам ДСТУ 3008:2015




 
2 ЗАВДАННЯ

Вивчити архітектуру системи розробки UI/UX-макетів Figma, з’ясувати його значення у розробці програмного забезпечення та основні принципи його роботи. Дослідити приклади використання Figma-API на мові JavaScript. 

3 ОПИС ВИКОНАНОЇ РОБОТИ

3.1 Аналіз архітектури Figma
Основна ідея архітектури Figma полягає в забезпеченні високопродуктивного хмарного дизайну інтерфейсів із підтримкою реального часу для командної роботи. Figma поєднує веб-технології, такі як WebSocket і WebGL, із масштабованою серверною інфраструктурою для обробки великих обсягів даних, таких як векторна графіка та бібліотеки компонентів. Це дозволяє досягти продуктивності, порівнянної з десктопними додатками, у браузері. Архітектура Figma реалізується через три ключові компоненти:
•	Клієнтська частина: Веб-додаток, що використовує WebGL для рендерингу та WebSocket для синхронізації;
•	Серверна частина: Масштабована інфраструктура на AWS із базою даних LiveGraph для реального часу;
•	Multiplayer: Система для синхронізації дій користувачів у файлі дизайну.
Основні принципи роботи:
•	Оптимізація обміну даними через запити за потребою;
•	Горизонтальне масштабування для обробки зростання навантаження;
•	Простота дизайну за принципом KISS із поступовим ускладненням.

3.2 Аналіз прикладів коду на мові JavaScript/TypeScript
Для поглибленого розуміння архітектури Figma було досліджено приклади коду, пов’язані з її функціоналом, на мові JavaScript/TypeScript. Приклади коду наведено у додатку В.

3.2.1 Використання Figma API у React
Реалізація взаємодії з Figma через REST API демонструє інтеграцію дизайну з кодом, що є ключовою частиною Dev Mode. У прикладі створено React-компонент FigmaComponents, який отримує компоненти файлу дизайну через API. Запит виконується з використанням токена автентифікації, а отримані дані відображаються в інтерфейсі. Компонент використовує хук useState для збереження стану та useEffect для асинхронного запиту.
Ця реалізація показує, як Figma підтримує автоматизацію через API, дозволяючи розробникам отримувати доступ до компонентів, стилів і змінних. Використання хуків React забезпечує інтеграцію з сучасними фронтенд-практиками, а ізоляція логіки запиту сприяє легшому тестуванню та підтримці коду. API-запити оптимізовано для зменшення навантаження, що відповідає принципам архітектури Figma.

3.2.2 Рендеринг графіки з TypeScript
Другий приклад демонструє рендеринг векторної графіки, що відображає підхід Figma до обробки візуальних елементів. У прикладі створено клас Rectangle, який реалізує інтерфейс Shape для малювання прямокутника на canvas через CanvasRenderingContext2D. 
Клас Rectangle інкапсулює логіку рендерингу, що відповідає модульному підходу Figma до обробки графіки. Використання TypeScript забезпечує строгую типізацію, що полегшує масштабування коду. 

4 ВИСНОВКИ

Архітектура Figma є ефективним рішенням для хмарного дизайну, що поєднує продуктивність десктопних додатків із гнучкістю веб-технологій. Вона забезпечує реальний час, масштабування та інтеграцію з кодом через WebSocket, LiveGraph і REST API. Особливо корисною для фронтенд-розробки є підтримка Dev Mode та API, що спрощують автоматизацію та синхронізацію дизайну з кодом.
Реалізація прикладів коду в React і TypeScript демонструє гнучкість архітектури Figma. Використання API дозволяє інтегрувати дизайн із фронтенд-додатками, а TypeScript забезпечує надійність рендерингу графіки. Модульність і оптимізація запитів сприяють підтримуванності коду.
Вибір такої архітектури для складних систем, як Figma, підвищує модульність, зменшує залежності та забезпечує масштабування. У порівнянні з іншими платформами, як Adobe XD чи Sketch, Figma вирізняється хмарною основою та реальним часом, що робить її оптимальною для динамічної командної роботи. 
ДОДАТОК А ПОСИЛАННЯ НА ВІДЕОЗАПИС ДОПОВІДІ ТА ХРОНОЛОГІЧНИЙ ОПИС

Відеозапис доповіді на YouTube: https://youtu.be/FNyVCW9P63Q
Розділи відео: 
00:00 Вступ. Пояснення теми та мети роботи 
00:38 Що таке Figma 
01:16 Чому Figma складна
01:53 Ключові принципи архітектури 
02:29 Клієнт-серверна взаємодія 
03:07 База даних Figma 
03:45 Синхронізація в реальному часі 
04:20 Компоненти та бібліотеки 
04:52 Figma Dev Mode 
05:33 Безпека та відповідність стандартам 
06:05 Виклики масштабування 
06:40 Порівняння з іншими системами 
07:13 Skew та TypeScript у Figma 
07:47 Майбутнє архітектури Figma 
08:20 Висновки 
08:50 Використані джерела 
ДОДАТОК Б
Презентація
 
Рисунок Б.1 – Титульна сторінка презентації

 
Рисунок Б.2 – Що таке Figma
 
Рисунок Б.3 – Чому Figma складна

 
Рисунок Б.4 – Ключові принципи архітектури
 
Рисунок Б.5 – Клієнт-серверна взаємодія

 
Рисунок Б.6 – База даних Figma


 
Рисунок Б.7 – Синхронізація в реальному часі

 
Рисунок Б.8 – Компоненти та бібліотеки
 
Рисунок Б.9 – Figma Dev Mode

 
Рисунок Б.10 – Безпека та відповідність стандартам
 
Рисунок Б.11 – Виклики масштабування

 
Рисунок Б.12 – Порівняння з іншими системами
 
Рисунок Б.13 – Skew та TypeScript у Figma

 
Рисунок Б.14 – Майбутнє архітектури Figma
 
Рисунок Б.15 – Висновки

 
Рисунок Б.16 – Використані джерела

 
ДОДАТОК В ПРОГРАМНИЙ КОД
(figma-api.js)
1  fetch('https://api.figma.com/v1/files/{file_key}/components', {
2    headers: { 'X-Figma-Token': 'YOUR_TOKEN' }
3  })
4    .then(res => res.json())
5    .then(data => console.log(data.meta));


(rectange.ts)
1  interface Shape {
2    render(ctx: CanvasRenderingContext2D): void;
3  }
4  class Rectangle implements Shape {
5    constructor(private x: number, private y: number, private w: number, private h: number) {}
6    render(ctx: CanvasRenderingContext2D) {
7      ctx.fillRect(this.x, this.y, this.w, this.h);
8    }
9  }
